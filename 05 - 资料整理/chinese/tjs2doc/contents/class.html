<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html  xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh" lang="zh">
<!-- generated by to_html.pl from class.xml -->
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
	<title>类(class)</title>
	<meta name="author" content="W.Dee" />
	<meta http-equiv="Content-Style-Type" content="text/css" />
	<meta http-equiv="Content-Script-Type" content="text/javascript" />
	<link href="browser.css" type="text/css" rel="stylesheet" title="åéåéç¸å³æ ååèæ ·å¼" />
	<link href="mailto:dee@kikyou.info" rev="Made" />
	<link href="index.html" target="_top" rel="Start" title="é¦é¡µ" />
</head>
<body>
<h1><a id="id44" name="id44">类(class)</a>
</h1><div class="para"><div>
　“类”是创建“对象”时使用的“模型”。类中的变量称为“成员变量”、类中的函数称为“成员函数”、或者叫做“方法”、类中的属性称为“成员属性”。<br />
<br />
　类的声明就象下面这样。<br />

<br />
<code class="bq"><a id="id45" name="id45" class="targanchor"><dfn>class</dfn></a>&nbsp;classname<br />
{<br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;定义成员变量，成员函数和成员属性</span><br />
<br />
&nbsp;&nbsp;&nbsp;&nbsp;function&nbsp;classname()&nbsp;<span class="comment">//&nbsp;构造函数</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;}<br />
<br />
&nbsp;&nbsp;&nbsp;&nbsp;function&nbsp;<a id="id46" name="id46" class="targanchor"><dfn>finalize</dfn></a>()&nbsp;<span class="comment">//&nbsp;这个相当于析构函数</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;}<br />
}<br />
<br />
</code>
<br />

<br />
　指定一个标识符作为类名。<br />
<br />
　在类的内部定义变量、函数和属性，作为类的成员。<br />
<br />
　在类的定义中必须有一个和类同名的成员函数，这个成员函数被称为“<a id="id47" name="id47" class="targanchor"><dfn>构造函数</dfn></a>”。使用<a id="id48" name="id48" class="targanchor"><dfn>new</dfn></a> 运算符创建这个类的对象的时候，这个函数就会作为 new 运算符的参数而被调用。<br />
<br />
　在类的定义中同样存在一个名为“finalize”的特殊的成员函数。这个函数会在对象销毁时被调用、可以省略。就算不写也没关系(如果想在对象销毁时做一些自己想做的事，就可以自己定义这个函数，把想要进行的操作写进去)。<br />
<br />

<br />
<code class="bq"><span class="weak">例:</span><br />&nbsp;&nbsp;&nbsp;&nbsp;class&nbsp;test<br />
&nbsp;&nbsp;&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;function&nbsp;test()<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;构造函数</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;在这里填写对象创建时需要处理的内容。</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;variable&nbsp;=&nbsp;0;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;function&nbsp;finalize()<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;finalize&nbsp;方法</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;在这里填写对象销毁时需要处理的内容。</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;function&nbsp;method1()<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;方法</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.inform(variable);<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;variable;&nbsp;<span class="comment">//&nbsp;成员变量</span><br />
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;property&nbsp;prop&nbsp;<span class="comment">//&nbsp;成员属性</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;getter()&nbsp;{&nbsp;return&nbsp;variable;&nbsp;}&nbsp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />
&nbsp;&nbsp;&nbsp;&nbsp;}<br />
</code>
<br />

<br />
对类使用 instanceof 运算符和 &quot;Class&quot; 操作数时，会得到“真”(true)的结果(以上面的那个类为例、test instanceof &quot;Class&quot; 是“真”)。<br />
</div></div>
<h1><a id="id49" name="id49">对象的创建</a>
</h1><div class="para"><div>
　已定义的类的对象使用 new 运算符来创建。<br />
　new 运算符的后面像函数那样指定类名和传递给构造函数的参数。<br />

<br />
<code class="bq"><span class="weak">例:</span><br />&nbsp;&nbsp;&nbsp;&nbsp;class&nbsp;Test<br />
&nbsp;&nbsp;&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;variable1&nbsp;=&nbsp;getValue();&nbsp;<span class="comment">//&nbsp;成员变量的初始化</span><br />
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;function&nbsp;Test(arg1,&nbsp;arg2)&nbsp;<span class="comment">//&nbsp;构造函数</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;使用&nbsp;new&nbsp;运算符创建对象时指定的参数会被传到&nbsp;arg1&nbsp;和&nbsp;arg2&nbsp;这两个变量里</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />
&nbsp;&nbsp;&nbsp;&nbsp;}<br />
<br />
&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;newobject&nbsp;=&nbsp;new&nbsp;Test(1,&nbsp;2);&nbsp;<span class="comment">//&nbsp;把&nbsp;1&nbsp;和&nbsp;2&nbsp;作为参数传入，创建&nbsp;test&nbsp;类的对象</span><br />
</code>
<br />

<br />
　对象在创建时的处理顺序如下。<br />
<br />
<ol><li>首先创建一个空的对象</li><li>注册方法和属性</li><li>创建成员函数 ( 有必要初始化的变量会在这时初始化 )</li><li>执行构造函数</li></ol><br /><div class="note"><div class="notehead"><span class="noteheadspan">Note</span></div>
　即使在构造函数不需要参数的时候也不能省略 new 运算符和类名后面的  ( ) 。像 JavaScript 那样写成 new Test 是不行的。必须写成 new Test( ) 。<br />
</div><br />
<br />
　注意，在类的方法和属性里创建该类的对象或该类的超类的对象的时候，象下面这样写是错误的。<br />

<br />
<code class="bq"><span class="weak">例:</span><br />&nbsp;&nbsp;&nbsp;&nbsp;class&nbsp;Test<br />
&nbsp;&nbsp;&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;function&nbsp;Test()&nbsp;<span class="comment">//&nbsp;构造函数</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;function&nbsp;func()<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;new&nbsp;Test();&nbsp;<span class="comment">//&nbsp;错误</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />
&nbsp;&nbsp;&nbsp;&nbsp;}<br />
</code>
<br />

<br />
　其原因在于，在类的方法或属性里只写 Test 的话、因为相对于类名的 Test 构造函数的 Test 在范围上更接近，这个 Test 会被当作构造函数来处理。为了避免这种情况，应该像下面这样明确地使用 global. 来指定类名 ( 因为类已经注册到 global 里了 )。<br />
<br />

<br />
<code class="bq"><span class="weak">例:</span><br />&nbsp;&nbsp;&nbsp;&nbsp;class&nbsp;Test<br />
&nbsp;&nbsp;&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;function&nbsp;Test()&nbsp;<span class="comment">//&nbsp;构造函数</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;function&nbsp;func()<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;new&nbsp;global.Test();&nbsp;<span class="comment">//&nbsp;这样写就OK了</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />
&nbsp;&nbsp;&nbsp;&nbsp;}<br />
</code>
<br />

</div></div>
<h1><a id="id50" name="id50">对象的销毁</a>
</h1><div class="para"><div>
　在 TJS2 语言中，销毁对象时分为对象的<a id="id51" name="id51" class="targanchor"><dfn>无效化</dfn></a>和对象的销毁两个步骤。<br />
　对象被无效化的时候会调用 finalize 方法，然后该对象会被置上无效的标记。以后对该对象的所有操作都会失败并产生异常。可以通过调用 <a id="id52" name="id52" class="targanchor"><dfn>isvalid</dfn></a> 运算符来判断一个对象是否已经失效。<br />
<br />
　使用 <a id="id53" name="id53" class="targanchor"><dfn>invalidate</dfn></a> 运算符来对对象进行无效化操作。<br />
<br />

<br />
<code class="bq"><span class="weak">例:</span><br />&nbsp;&nbsp;&nbsp;&nbsp;class&nbsp;Test<br />
&nbsp;&nbsp;&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;variable;<br />
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;function&nbsp;Test()<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;构造函数</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;variable&nbsp;=&nbsp;new&nbsp;AnotherClass();<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;function&nbsp;finalize()<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;finalize&nbsp;方法会在对象被无效化的时候会调用</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;invalidate&nbsp;variable;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />
&nbsp;&nbsp;&nbsp;&nbsp;}<br />
<br />
&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;object&nbsp;=&nbsp;new&nbsp;Test();&nbsp;<span class="comment">//&nbsp;对象的创建</span><br />
<br />
&nbsp;&nbsp;&nbsp;&nbsp;(略)<br />
<br />
&nbsp;&nbsp;&nbsp;&nbsp;invalidate&nbsp;object;&nbsp;<span class="comment">//&nbsp;对象的无效化</span><br />
</code>
<br />

<br />
　即使不使用 invalidate 运算符来操作，对象也会在没用了的时候被删除。没有被无效化的对象在这时候会被无效化。<br />
　TJS2中并没有对“什么时候对象会被销毁”进行明确规定，销毁和无效化“随时可能发生”。未无效化的对象在被销毁时会先被无效化，此时可能会自动调用 finalize 方法。为了避免这一点，建议在对象用完之后使用 invalidate 运算符对其进行无效化。<br />
<br />
<br /><div class="note"><div class="notehead"><span class="noteheadspan">Note</span></div>
　invalidate 运算符的行为类似于 C++ 中的 delete 运算符。<br />
　TJS2 中的 delete 运算符和 C++ 中的 delete 运算符是不一样的，TJS2 中的 delete 是用来消除成员或全局变量的运算符。虽然 delete 运算符无法直接对对象进行无效化或删除，但是成员或全局变量的删除会引起其内部对象的无效化和删除。<br />
</div><br />
</div></div>
<h1><a id="id54" name="id54">对对象的操作</a>
</h1><div class="para"><div>
　已创建的对象的成员变量、方法和成员属性可以通过 <a id="id55" name="id55" class="targanchor"><dfn>.</dfn></a> (成员选择运算符) 或者 <a id="id56" name="id56" class="targanchor"><dfn>[ ]</dfn></a> (间接成员选择运算符) 来操作。<br />

<br />
<code class="bq"><span class="weak">例:</span><br />&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;obj=new&nbsp;MyLayer(window,window.prmaryLayer)<br />
&nbsp;&nbsp;&nbsp;&nbsp;obj.method1();&nbsp;<span class="comment">//&nbsp;方法的调用&nbsp;或者写成&nbsp;obj['method1']()&nbsp;也可以</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;obj.num&nbsp;=&nbsp;3;&nbsp;<span class="comment">//&nbsp;成员变量的赋值&nbsp;或者写成&nbsp;obj['num']&nbsp;=&nbsp;3&nbsp;也可以</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;obj.prop1++;&nbsp;<span class="comment">//&nbsp;成员属性的自增操作&nbsp;或者写成&nbsp;obj['prop1']++&nbsp;也可以</span><br />
</code>
<br />

</div></div>
<h1><a id="id57" name="id57">闭包(Closure)</a>
</h1><div class="para"><div>
　已创建的对象的方法和属性是携带着“属与哪个对象”的信息被注册到对象中的。<br />
　因此，这些方法和属性从对象中取出，单独使用时，仍是对其所属对象的操作。这一机能被称为闭包(Closure)。那个被操作的对象称为<a id="id58" name="id58" class="targanchor"><dfn>上下文(context)</dfn></a>。<br />

<br />
<code class="bq"><span class="weak">例:</span><br />&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;obj&nbsp;=&nbsp;new&nbsp;FooBarClass();&nbsp;<span class="comment">//&nbsp;创建对象</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;obj.method();&nbsp;<span class="comment">//&nbsp;用常规手段调用对象的方法</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;objmethod&nbsp;=&nbsp;obj.method;&nbsp;<span class="comment">//&nbsp;把指向对象中方法的引用代入到&nbsp;objmethod&nbsp;变量</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;objmethod();&nbsp;<span class="comment">//&nbsp;调用&nbsp;objmethod&nbsp;和调用&nbsp;obj.method()&nbsp;一样，都是对&nbsp;obj&nbsp;这个对象的操作</span><br />
</code>
<br />

<br />
　<a id="id59" name="id59" class="targanchor"><dfn>incontextof</dfn></a> 运算符提供了修改函数中“作为哪个对象的方法”这一信息，让某个函数作为任意对象中的方法来调用的功能。<br />

<br />
<code class="bq"><span class="weak">例:</span><br />&nbsp;&nbsp;&nbsp;&nbsp;(objmethod&nbsp;incontextof&nbsp;obj2)();&nbsp;<span class="comment">//&nbsp;对&nbsp;obj2&nbsp;进行操作</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;(objmethod&nbsp;incontextof&nbsp;this)();&nbsp;<span class="comment">//&nbsp;对&nbsp;this&nbsp;进行操作</span></code>
<br />

</div></div>

<h1><a id="id60" name="id60">继承</a>
</h1><div class="para"><div>
　使用关键字 <a id="id61" name="id61" class="targanchor"><dfn>extends</dfn></a> 可以让一个类继承其他的类。继承操作中，源类的成员都会被目的类继承下来。<br />
　被继承的类称之为<a id="id62" name="id62" class="targanchor"><dfn>超类(super class)</dfn></a>，继承出来的类称之为<a id="id63" name="id63" class="targanchor"><dfn>子类(sub class)</dfn></a>。<br />
　以如下方式定义类。<br />

<br />
<code class="bq"><span class="weak">例:</span><br />&nbsp;&nbsp;&nbsp;&nbsp;class&nbsp;Class1&nbsp;<span class="comment">//&nbsp;超类</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;function&nbsp;Class1()&nbsp;<span class="comment">//&nbsp;Class1&nbsp;的构造函数</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;function&nbsp;finalize()&nbsp;<span class="comment">//&nbsp;Class1&nbsp;finalize</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;function&nbsp;method1()&nbsp;<span class="comment">//&nbsp;method1</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />
&nbsp;&nbsp;&nbsp;&nbsp;}<br />
<br />
<br />
&nbsp;&nbsp;&nbsp;&nbsp;class&nbsp;Class2&nbsp;extends&nbsp;Class1<br />
&nbsp;&nbsp;&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;function&nbsp;Class2()&nbsp;<span class="comment">//&nbsp;Class2&nbsp;构造函数</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super.Class1();&nbsp;<span class="comment">//&nbsp;调用&nbsp;Class1&nbsp;的构造函数</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;function&nbsp;finalize()&nbsp;<span class="comment">//&nbsp;Class2&nbsp;finalize</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super.finalize();<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />
&nbsp;&nbsp;&nbsp;&nbsp;}<br />
<br />
&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;obj&nbsp;=&nbsp;new&nbsp;Class2();&nbsp;<span class="comment">//&nbsp;创建&nbsp;Class2&nbsp;的对象</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;obj.method1();&nbsp;<span class="comment">//&nbsp;Class2&nbsp;调用了从&nbsp;Class1&nbsp;中继承的&nbsp;method1&nbsp;方法</span><br />
</code>
<br />

　上在上面的例子中、Class2 继承了 Class1 。或者称为 Class2 由 Class1 <a id="id64" name="id64" class="targanchor"><dfn>派生</dfn></a> 而来。<br />
　Class2 的构造函数内调用了 Class1 的构造函数，Class2 的 finalize 内调用了 Class1 的 finalize 。<em>子类的这些方法中没有调用超类的对应的方法的时候，其结果是不可预知的</em> ( 现在的版本中并没有对是否调用进行检测 ) ，所以请务必手动调用超类对应的函数。<br />
<br />
　为了在子类中调用超类的成员，可以使用 <a id="id65" name="id65" class="targanchor"><dfn>super</dfn></a> 运算符。这个关键字在子类中才能使用，代表所在类的超类。<br />
<br />
　在进行了继承的情况下，用 new 运算符创建对象时的初始化顺序如下。<br />
<br />
<ol><li>首先创建空的对象</li><li>注册方法和属性( 从超类的方法和属性开始，然后才是子类的 )</li><li>创建成员变量 ( 从超类的成员变量开始，然后才是子类的 )</li><li>调用子类的构造函数</li><li>( 从子类的构造函数里 ) 调用超类的构造函数</li></ol></div></div>
<h1><a id="id66" name="id66">多重继承</a>
</h1><div class="para"><div>
　在 extends 后面填写多个超类的类名，就可以进行多重继承。<br />

<br />
<code class="bq"><span class="weak">例:</span><br />&nbsp;&nbsp;&nbsp;&nbsp;class&nbsp;SubClass&nbsp;extends&nbsp;ClassA,&nbsp;ClassB<br />
&nbsp;&nbsp;&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;function&nbsp;SubClass()&nbsp;<span class="comment">//&nbsp;SubClass&nbsp;构造函数</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ClassA();&nbsp;<span class="comment">//&nbsp;调用&nbsp;ClassA&nbsp;的构造函数</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ClassB();&nbsp;<span class="comment">//&nbsp;调用&nbsp;ClassB&nbsp;的构造函数</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;function&nbsp;finalize()&nbsp;<span class="comment">//&nbsp;Class2&nbsp;finalize</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;global.ClassA.finalize();<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;global.ClassB.finalize();<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />
&nbsp;&nbsp;&nbsp;&nbsp;}<br />
<br />
</code>
<br />

　在这里不能使用 super 关键字，必须明确指定超类的类名。调用超类的方法时用 global. 后面跟各个类名来对类进行操作，例如在子类中单独指定 ClassA 及其构造函数。因为类本身已经在 global 中注册了，所以使用 global. 可以对类进行操作。<br />
<br />
　进行多重继承的情况下，用 new 运算符创建对象时的初始化顺序和非多重继承的情况相同，超类的方法和属性的注册顺序依照 extends 关键字后面的类名的顺序。如果被继承的类之间有同名的方法或属性的话，写在后面的类优先。被隐藏的方法和属性可以通过明确指定类名，用 global.ClassA.hiddenMethod() 这样的方式来调用。<br />
</div></div>
<h1><a id="id67" name="id67">override</a>
</h1><div class="para"><div>
　译者注：“オーバーライド”貌似应该翻译成 “override”，这在中文的C++相关资料中被称为“覆盖”。但是，在TJS2中没有虚函数和晚捆绑机制以及多态性，所以，以下将这一现象称为“隐藏”。感谢Bruce Eckel和他的《Thinking in C++》。<br />
<br />
　子类中定义了和超类中同名的方法和属性时，超类的成员会被隐藏。这被称为“override”。<br />
　上面那段说明中子类的 finalize 方法就把超类的 finalize 方法隐藏了。<br />

<br />
<code class="bq"><span class="weak">例:</span><br />&nbsp;&nbsp;&nbsp;&nbsp;class&nbsp;Class1&nbsp;<span class="comment">//&nbsp;超类</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;function&nbsp;Class1()&nbsp;<span class="comment">//&nbsp;Class1&nbsp;构造函数</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;function&nbsp;finalize()&nbsp;<span class="comment">//&nbsp;Class1&nbsp;finalize</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;function&nbsp;method1()&nbsp;<span class="comment">//&nbsp;method1</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(略)<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />
&nbsp;&nbsp;&nbsp;&nbsp;}<br />
<br />
<br />
&nbsp;&nbsp;&nbsp;&nbsp;class&nbsp;Class2&nbsp;extends&nbsp;Class1<br />
&nbsp;&nbsp;&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;function&nbsp;Class2()&nbsp;<span class="comment">//&nbsp;Class2&nbsp;构造函数</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super.Class1();&nbsp;<span class="comment">//&nbsp;调用&nbsp;Class1&nbsp;的构造函数</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;function&nbsp;finalize()&nbsp;<span class="comment">//&nbsp;Class2&nbsp;finalize</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super.finalize();<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;function&nbsp;method1()&nbsp;<span class="comment">//&nbsp;隐藏&nbsp;Class1.method1&nbsp;</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(略)<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(略)&nbsp;return&nbsp;super.method1();<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(略)<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />
&nbsp;&nbsp;&nbsp;&nbsp;}<br />
<br />
&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;obj&nbsp;=&nbsp;new&nbsp;Class2();&nbsp;<span class="comment">//&nbsp;创建&nbsp;Class2&nbsp;对象</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;obj.method1();&nbsp;<span class="comment">//&nbsp;调用&nbsp;Class2&nbsp;的&nbsp;method1&nbsp;方法</span><br />
</code>
<br />

　在子类的方法或属性中可以用 super 关键字来调用超类的方法或属性。<br />
<br />
　成员变量无法隐藏。成员变量是针对某一个对象进行注册的，子类可以和超类有相同名字的成员函数
但子类的成员变量会把超类的成员变量覆盖掉。<br />
</div></div>
	<script type="text/javascript" charset="UTF-8" src="documentid.js" ></script>
	<script type="text/javascript" charset="UTF-8" src="postcontent.js" ></script>
</body>
</html>
