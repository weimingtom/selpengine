<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html  xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh" lang="zh">
<!-- generated by to_html.pl from ReadUnread.xml -->
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
	<title>未读/已读处理</title>
	<meta name="author" content="W.Dee" />
	<meta http-equiv="Content-Style-Type" content="text/css" />
	<meta http-equiv="Content-Script-Type" content="text/javascript" />
	<link href="browser.css" type="text/css" rel="stylesheet" title="åéåéç¸å³æ ååèæ ·å¼" />
	<link href="mailto:dee@kikyou.info" rev="Made" />
	<link href="index.html" target="_top" rel="Start" title="é¦é¡µ" />
</head>
<body>
<h1><a id="id181" name="id181">未读/已读处理</a>
</h1><div class="para"><div>
　未读部分指玩家还没有执行过的剧本、已读部分则是玩家已经看过的部分。<br />
　KAG 中，支持未读/已读部分的文字显示速度不同，已读部分的 [l] 指令无效等功能。<br />
<br />
　未读/已读，是使用系统变量进行记录的、命名格式以 <code class="inlinecode">trail_</code> 开头。要进行未读/已读记录，请在 <code class="inlinecode">Config.tjs</code> 里将 <code class="inlinecode">autoRecordPageShowing</code> 设为 true 。<br />
</div></div>
<h1><a id="id182" name="id182">未读部分和已读部分</a>
</h1><div class="para"><div>
　KAG 中、未读部分/已读部分的判断是使用标签进行的。<br />
　负责记录的系统变量以 <code class="inlinecode">trail_脚本文件名_标签名</code> 这样的格式命名。例如、记录 first.ks 的 *start 标签是否已经执行过的变量，就是 <code class="inlinecode">sf.trail_first_start</code> 了。<br />
　这个变数值为 void ( 也就是未定义; 作为数值判断的话，相当于 0  ) 时表示未读、1 以上则是已读。1 以上的情况，代表执行过的次数。<br />
<br />
　基本上、一个标签开始，一直到下一个标签，或者到 [s] 指令，这样的一个剧本段被当作一个「段落」来处理。<br />
　例如、以下这样的剧本内容、三种颜色分别代表三个段落。<br />
<br />
<html><head></head><body><table width="100%">

<tbody><tr><td bgcolor="#ffc0c0"><span class="script">

*第1段落<br>

@cm<br>

这里是第1段落。[l][r]<br>

一般来说，到下一标签之前的剧本段，称为一个「段落」。[p][r]<br>

</span></td></tr>

<tr><td bgcolor="#c0ffc0"><span class="script">

*第2部分<br>

@cm<br>

这里是第2段落。[p][r]<br>

</span></td></tr>

<tr><td bgcolor="#c0c0ff"><span class="script">

*第3段落<br>

@cm<br>

这里是第3段落。[l][r]<br>

到[[s]指令为止也算是一个「段落」。[s]<br>

</span></td></tr>

</tbody></table>

</body></html><br />
　以这些「段落」为单位、进行未读/已读的判断。<br />
<br />
　一开始，所有段落都处在未读状态。<br />
</div></div>
<h1><a id="id183" name="id183">已读判断</a>
</h1><div class="para"><div>
　某个「段落」是否已读，原则上是这样判断的：「执行到遇到下一个标签/执行到遇到 [s] 指令」，这样的话这个「段落」就被视为已读，并在系统变数里记录。<br />
　也就是说，玩家在「段落」执行到一半的时候，关闭程序的话，这一段就不会被记录为已读。也就是说不执行到「段落」的最后就没有效果。<br />
</div></div>
<h1><a id="id184" name="id184">剧本跳转和已读判断</a>
</h1><div class="para"><div>
　假如剧本中存在 jump 指令，或者使用 link 分歧，也就是剧本有多个分支的情况下，又和上面说的不太一样。<br />
<br />
<dl>
<dt>link 类 ( link 或 button 指令 ) 进行跳跃的情况</dt>
<dd>　这类型的指令，在玩家进行选择之后跳转到其他剧本段落时，自动记录为已读。<br />
　例如以下的例子、<br />

<br />
<code class="bq">*select<br />
这个部分，在玩家选择的时候就被判断为已读。[r]<br />
[link&nbsp;target=*t1]選択肢1[endlink][r]<br />
[link&nbsp;target=*t2]選択肢2[endlink][r]<br />
@wait&nbsp;time=3000<br />
@jump&nbsp;target=*timeout<br />
</code>
<br />

　假如玩家在 @wait 指令的等待时间结束前，做出了选择的话，这部分会被判断为已读。顺便一说，一般的选择支都会在 link 指令后面加上 [s] ，那么在执行到 [s] 的时候就已经被判断为已读了。<br />
　link 指令和 button 指令等等，都有 contpage 属性、将这个属性设为 false 的话，即使从这里跳跃到其他段落，原来的段落也不会被判断为已读。</dd>
<dt>jump 指令</dt>
<dd>　jump 指令进行跳跃的话，也会被自动判断为已读。jump 指令也有 coutpage 属性、设为 false 的话，即使跳转，原来的段落也不会被视为已读。</dd>
<dt>call 和 return</dt>
<dd>　call 呼叫其他剧本段落的话，原段落不会被视为已读。call 指令也具有 coutpage 属性、设为 true 的话，呼叫的时候，原来的段落被视为已读。<br />
　retrun 指令的话，会进行既读判断 ( 注意不是进行呼叫的段落的已读判断，而是将被呼叫的段落，也就是 return 指令所在的段落被判断为已读 )。同样将 coutpage 属性设为 false 的话，就不会被判定为已读。</dd></dl></div></div>
	<script type="text/javascript" charset="UTF-8" src="documentid.js" ></script>
	<script type="text/javascript" charset="UTF-8" src="postcontent.js" ></script>
</body>
</html>
